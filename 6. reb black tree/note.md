# 红黑树

一种**平衡树**（balanced tree），树作为一种动态集合，它的增删改查的时间效率依赖于树的深度。“平衡的“查找树能保证最坏情况下，树高是 O(log n)

红黑树的性质是：

1. 每个结点要么是红的，要么是黑的
2. 根节点是黑的
3. 每个叶子结点都是黑的（并且非叶子结点都有两个叶子结点，不包括键值的叶子是 NIL）
4. 如果一个节点是红的，则它的两个儿子都是黑的
5. 对每个结点，该结点到任意叶子的所有路径上包含相同数量的黑结点。

# 红黑树为什么平衡的证明

由性质 5： 从某结点 x 除法，到达任何一个叶节点的任意一条路径上，经过黑色结点的个数为 x 的**黑高度**，用 bh(x) 来表示。

定理：一个有 n 个内结点的红黑树的高度至多为 **2lg(n + 1)**

证明：先引入一个引理：以结点 x 为根的子树至少包含 2^bh(x) - 1 个内结点。

使用数学归纳法：

1. 当 x 高度为 0，则 x 就是一个叶节点，内结点是 2^0 -1 = 0 个，结论成立。
2. 当 bh(x) > 0，则 x 就是一个内结点。他的左右儿子根据其颜色是黑或红，黑高度就是bh(x) 或 bh(x) - 1 ，对于两者，至少包含 2 * [2^(bh(x)-1) - 1] = 2^bh(x) - 2 个内结点，加上 x 本身，就是 2^bh(x) - 1 个内结点，归纳证明完毕。

因此，设 h 为树的高度的话， 根据性质 4 ，一棵红黑树不会有连续的两个红结点。因此我们得到黑高度 bh(x) >= h /2 ，即：黑高度至少是树高的一半。

n ≥ 2^(h/2) - 1

变换得： h ≤ 2 lg(n + 1)

![](http://osax8w13y.bkt.clouddn.com/rbt1.png)

# 旋转

旋转是一种能保持二叉查找树局部性质的变换操作。

# 插入

插入一个结点的时候，总认为是红色的。如果说插到黑色结点后面，就一点事也没有。插入到红色之后，就违反了性质 4 （不能有连续两个红）

这时候，就主要看叔叔了。根据不同的情况，做颜色修改或者旋转。叔叔如果是红色 // case 1

叔叔如果是黑色且插入的节点是右孩子 // case 2 

叔叔如果是黑色且插入的节点是左孩子 // case 3

（这里就不详细说明了）

很有意思的是，红黑树的 Insert fixup 该过程所做的旋转**从来不超过两次**，因为只要进入 case 2 或者 case 3 循环就结束

# 删除

如果删除的节点 y 是红色，则一点事没有。如果删除的 y 是黑色，会有两个破坏性质的问题：

1. 如果 y->parent 与其（唯一一个）孩子 x 都是红的就违反了性质 4 
2. 因为删除了 y ，所有导致任何包含 y 的路径上的黑色结点数少 1 ，违反了性质 5 。补救的方法是**把 x 视为有额外的一重黑色**，好像“把 y 删除时，将其黑色的属性下加到子节点 x”。现在把问题转移成 **x 的颜色问题**，x 原来如果是黑，就变成了 **双重黑色**，x 原来如果是红，就变成了 **红黑色**。然而性质 1 要求每个结点只能是红色或者黑色。此时的处理方法就是 **把黑色（ x ）沿树上移，直到**

    - x 成为红黑结点，那就将 x 单独着为黑色即可。
    - x 成为根节点，着为黑色即可。
    - 做必要的选择或者颜色修改。

（这里就不详细说明了）

很有意思的是，红黑树的 Delete fixup 该过程所做的旋转**从来不超过三次**。

![](http://osax8w13y.bkt.clouddn.com/rbt2.png)

# 红黑树与 BST

红黑树本身是一棵 BST，但在代码的写法中要注意把有关 NULL 的引用改成 nil（包括所有操作中）

# 参考链接

-[红黑树并没有我们想象的那么难(上)](http://daoluan.net/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2013/09/25/rbtree-is-not-difficult.html)

-[浅谈算法和数据结构: 九 平衡查找树之红黑树](http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html) 